#!/usr/bin/python
""" Script to interpolate regular gridded data onto another grid.

Also converts all units from Bohr to Angstroms.
Usage: python CubeFileProcessor.py [cube-file name]
[no. of grid points in X-direction] [no. of grid points in Y-direction]
[no. of grid points in Z-direction] > [output file]
"""
import sys
import scipy.interpolate as interpolate
import numpy as np
# Bohr to angstrom [ref: https://www.convertunits.com/from/bohr/to/angstrom]
l_conv = 0.52918
# Cube file specification
#[ref: http://h5cube-spec.readthedocs.io/en/latest/cubeformat.html]
# No. of comment lines in header
Nc = 2
# Main function
def _main(a_f,Nn):
    # original grid
    M = [0 for dim in range(3)]
    with open(a_f,'r') as f:
        # skip comment lines in the beginning
        for i in range(Nc):
            f.readline()
        # endfor #
        l = f.readline().split()
        # No. of atoms
        Nat = int(l[0])
        print '%6d'%(Nat),
        for dim in range(3):
            print '%12.6f'%(l_conv * float(l[dim+1])),
        # endfor #
        print ''
        # Grid size and unit vector in each direction
        for dim in range(3):
            l = f.readline().split()
            u = [0.0 for dm in range(3)]
            M[dim] = int(l[0])
            u[dim] = l_conv * float(l[dim+1])
            print '%6d %12.6f %12.6f %12.6f'%(Nn[dim], u[0], u[1], u[2])
        # endfor #
        for at in range(Nat):
            l = f.readline().split()
            # Print atomic no. and charge
            print '%6d %12.6f'%(int(l[0]), float(l[1])),
            for dim in range(3):
                print '%12.6f'%(l_conv * float(l[dim+2])),
            # endfor #
            print ''
        # endfor #
        # Total no. of data points
        ndt = M[0] * M[1] * M[2]
        # Array to store data points
        dt = np.zeros(ndt)
        # initialize iterator over no. of data points
        idt = 0
        for l in f:
            for d in l.split():
                dt[idt] = float(d) / l_conv**3
                idt = idt+1
            # endfor #
            if idt == ndt:
                break
            # endif #
        # endfor #
    # endwith #
    # reshape data array to required dimension using column-major FORTRAN
    # ordering as it's given in the data file
    rd = dt.reshape(M[0],M[1],M[2],order='C')
    # original grid points along each axis
    m1 = np.linspace(0,1,M[0])
    m2 = np.linspace(0,1,M[1])
    m3 = np.linspace(0,1,M[2])
    # new grid points along each axis
    n1 = np.linspace(0,1,Nn[0])
    n2 = np.linspace(0,1,Nn[1])
    n3 = np.linspace(0,1,Nn[2])
    # constructing new grid points as required by interpn
    Nx,Ny,Nz = np.meshgrid(n1,n2,n3,indexing='ij')
    NNx = Nx.flatten()
    Nndt = Nn[0] * Nn[1] * Nn[2]
    NNx.shape = (Nndt,1)
    NNy = Ny.flatten()
    NNy.shape = (Nndt,1)
    NNz = Nz.flatten()
    NNz.shape = (Nndt,1)
    N = np.concatenate((NNx,NNy,NNz),axis=1)
    # do the interpolation
    intdt = interpolate.interpn((m1,m2,m3),rd,N)
    for i in range(Nn[0]):
        for j in range(Nn[1]):
            for k in range(Nn[2]):
                print '%12.6E'%(intdt[i*Nn[1]*Nn[2]+j*Nn[2]+k]),
                if k % 6 == 5:
                    print ''
                # endif #
            # endfor #
            print ''
        # endfor #
    # endfor #
# enddef _main() #

if __name__ == "__main__":
    if ( len(sys.argv) != 5 ):
        sys.exit("Usage: python CubeFileProcessor.py [CUBE-FILE name] "
                +"[no. of grid points in X-direction] "
                +"[no. of grid points in Y-direction] "
                +"[no. of grid points in Z-direction] > [output file] ")
    # endif #
    # Filename containing data points
    fc = sys.argv[1]
    try:
        f = open(fc,'r')
        f.close()
    except IOError:
        sys.exit("CUBE file " + fc + " not found!")
    # endtry
    # New grid size
    N = [0 for dim in range(3)]
    for dim in range(3):
        try:
            N[dim] = int(sys.argv[dim+2])
            if N[dim] <= 0:
                sys.exit("Argument # " + str(dim+2) + " should be a positive "
                 + "integer")
            # endif #
        except ValueError:
            sys.exit("Argument # " + str(dim+2) + " should be an integer")
        # endtry #
    # endfor #
    print "  Cube file generated by Python script CubeFileProcessor.py"
    print "  All lengths in Angstroms and all charge in no. of electrons"
    _main(fc,N)
# endif #

